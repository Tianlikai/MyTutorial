# 前言

`作用域`被定义为一套规则，这套规则用来管理`引擎`如何在`当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找`。

作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域。

## 词法阶段

大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化），词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

简单地说，`词法作用域`就是定义在`词法阶段的作用域`。换句话说，`词法作用域`是由你在`写代码时将变量和块作用域写在哪里来决定的`，因此当词法分析器处理代码时会保持作用域
不变（大部分情况下是这样的）。

看下面的例子

```
  // (1) 包含着整个全局作用域，其中只有一个标识符：foo。
  function foo (a) {
    // (2) 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。
    var b = a * 2;
    function bar (c) {
      // (3) 包含着 bar 所创建的作用域，其中只有一个标识符：c。
      console.log(a, b, c);
    }
    bar(b * 3)
  }
  foo(2);
```

## 查找

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

在上一个代码片段中，引擎执行 console.log(..) 声明，并查找 a、b 和 c 三个变量的引
用。它首先从最内部的作用域，也就是 bar(..) 函数的作用域气泡开始查找。引擎无法在
这里找到 a，因此会去上一级到所嵌套的 foo(..) 的作用域中继续查找。在这里找到了 a，
因此引擎使用了这个引用。对 b 来讲也是一样的。而对 c 来说，引擎在 bar(..) 中就找到
了它。

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的
标识符，这叫作`“遮蔽效应”`（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，
作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见
第一个匹配的标识符为止。

## 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修
改”（也可以说欺骗）词法作用域呢？

JavaScript 中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是
什么好注意。但是关于它们的争论通常会忽略掉最重要的点：欺骗词法作用域会导致性能
下降。

### eval

在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插
入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

```
  function foo (str, a) {
    eval(str) // 词法欺骗
    console.log(a, b);
    // 此处的 b 永远也无法找到外部的b
    // 因为此处内部创建了一个 b 并且覆盖了外部的b
  }
  var b = 2;
  foo('var b = 3; ', a)

  // 注意 eval 语法在严格模式下有自己的作用域，所以无法修改作用域
```

### with

JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是
with 关键字。可以有很多方法来解释 with，在这里我选择从这个角度来解释它：它如何同
被它所影响的词法作用域进行交互。

with 通常被当作`重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。`

```
  var obj = {
    a: 1,
    b: 2,
    c: 3
  };

  // 重复编写 "obj"
  obj.a = 2;
  obj.b = 3;
  obj.c = 4;

  // 简单的快捷方式
  with (obj) {
    a = 3;
    b = 4;
    c = 5;
  }
```

## JavaScript 作用域

理解 JavaScript 作用域，要明白作用域在 js 中起到作用以及其 js 之间的关系。首先这里介绍 js 的三个重要角色。

- 引擎

  > 从头到尾负责整个 JavaScript 程序的编译及执行过程。

- 编译器

  > 引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。

- 作用域
  > 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查
  > 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

为了能够完全理解 JavaScript 的工作原理，你需要开始像引擎（和它的朋友们）一样思考，
从它们的角度提出问题，并从它们的角度回答这些问题。

### 引擎~编译器~作用域之间的协作

当我们运行到 var a = 2 时，这里会被解释为:

- 遇到 var a，`编译器会`询问`作用域`是否已经有一个该名称的变量存在于同一个作用域的
  集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
  用域的集合中声明一个新的变量，并命名为 a。

- 接下来`编译器`会为引擎生成`运行时`所需的代码，这些代码被用来处理 `a = 2` 这个赋值
  操作。`引擎运行时会首先询问作用域`，在当前的作用域集合中是否存在一个叫作 a 的
  变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

- 总结
  > 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如
  > 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对
  > 它赋值

### LHS 和 RHS

```
    /**
     * 这里对 a 进行了LHS查询
     * 当变量值出现在赋值操作符左侧时会进行LHS
     **/
    var a = 2

    /**
     * 这里对 a 进行了RHS查询
     * RHS 可译为（取到它的源值，获取某某的值）
     **/
    console.log(a)

    /**
     * 这里包含了一个隐藏的LHS
     * 当执行demo(...)时，会隐式的执行 a = 2
     **/
    function demo(a) {
        console.log(a)
    }
    demo(2)
```

### 引擎和作用域的对话

```
    function foo(a) {
      console.log( a ); // 2
    }
    foo( 2 );
```

让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。

- 引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？
- 作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
- 引擎：哥们太够意思了！好吧，我来执行一下 foo。
- 引擎：作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？
- 作用域：这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。
- 引擎：大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。
- 引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？
- 作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。给你。
- 引擎：么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。
- 引擎：哥们，能帮我再找一下对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。
- 作用域：放心吧，这个变量没有变动过，拿走，不谢。
- 引擎：真棒。我来把 a 的值，也就是 2，传递进 log(..)

### 作用域链

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用
域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是全局作用域）为止。

LHS 和 RHS 引用都会在当前作用域进行查找，如果没有找到，就会像冒泡一样前往上一层作用域，
如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你
所需的变量，也可能没找到，但无论如何查找过程都将停止。

### 异常

```
    function foo(a) {
        console.log( a + b );
        b = a;
    }
    foo( 2 );
```

当代码对 b 执行 RHS 查询时 遍历作用域也无法找到，此时会抛出 ReferenceError 异常。
但是当程序在执行 LHS 查询时 遍历作用域同样无法找到，在`非严格模式下`全局作用域会创建一个具有改名称的变量。

> ⚠️ 当 RHS 查找到一个指定变量，但是对该变量执行不合理操作时，会抛出 TypeError 异常。所以 ReferenceError 代表查找失败。TypeError 则查找成功。

### 来源

- 原文地址: [JavaScript 作用域](https://github.com/Tianlikai/MyTutorial/blob/master/scope/READE.md)
- react 撸后台: [企业级中后台项目](https://juejin.im/post/5b715c006fb9a009b628faaa)
