# javaScript 作用域总结

## 作用域

作用域是一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。

- 引擎~编译器~作用域之间的协作

  - 当我们运行到 var a = 2 时，这里会被解释为:

  - 遇到 var a，`编译器会`询问`作用域`是否已经有一个该名称的变量存在于同一个作用域的
    集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
    用域的集合中声明一个新的变量，并命名为 a。

  - 接下来`编译器`会为引擎生成`运行时`所需的代码，这些代码被用来处理 `a = 2` 这个赋值
    操作。`引擎运行时会首先询问作用域`，在当前的作用域集合中是否存在一个叫作 a 的
    变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

  - 总结

    > 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如
    > 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对
    > 它赋值

- LHS 和 RHS

  ```
    /**
     * 这里对 a 进行了LHS查询
     * 当变量值出现在赋值操作符左侧时会进行LHS
     **/
    var a = 2

    /**
     * 这里对 a 进行了RHS查询
     * RHS 可译为（取到它的源值，获取某某的值）
     **/
    console.log(a)

    /**
     * 这里包含了一个隐藏的LHS
     * 当执行demo(...)时，会隐式的执行 a = 2
     **/
    function demo(a) {
        console.log(a)
    }
    demo(2)
  ```

- 作用域链

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用
域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是全局作用域）为止。

LHS 和 RHS 引用都会在当前作用域进行查找，如果没有找到，就会像冒泡一样前往上一层作用域，
如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你
所需的变量，也可能没找到，但无论如何查找过程都将停止。

- 异常 ReferenceError 和 TypeError

在非严格模式下 LHS 应用如果没有找到变量，则会创建一个

RHS 应用如果没有找到变量则会抛出 ReferenceError，如果找到变量但是执行了一个不合法的操作则会抛出 TypeError

## 词法作用域

词法作用域是定义在词法阶段的作用域，由代码的位置决定。但是 eval 和 with 两个关键字存在词法欺骗

- eval

  > eval 会改变变量的词法作用域

  ```
  function foo (str, a) {
    eval(str) // 词法欺骗
    console.log(a, b);
    // 此处的 b 永远也无法找到外部的b
    // 因为此处内部创建了一个 b 并且覆盖了外部的b
  }
  var b = 2;
  foo('var b = 3; ', a)

  // 注意 eval 语法在严格模式下有自己的作用域，所以无法修改作用域
  ```

- with

  > 同样会改变变量的词法作用域，而且在非严格模式下会在 LHS 引用的过程中创建一个全局变量
  > with 通常被当作`重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身`。

  ```
  var obj = {
    a: 1,
    b: 2,
    c: 3
  };

  // 重复编写 "obj"
  obj.a = 2;
  obj.b = 3;
  obj.c = 4;

  // 简单的快捷方式
  with (obj) {
    a = 3;
    b = 4;
    c = 5;
  }

  console.log(obj) // 3, 4, 5
  ```

  ```
  function foo(obj) {
  with (obj) {
  a = 2;
  }
  }

  var o1 = {
  a: 3
  };

  var o2 = {
  b: 3
  };

  foo(o1);
  console.log(o1.a); // 2

  foo(o2);
  console.log(o2.a); // undefined

  console.log(a); // 2——不好，a 被泄漏到全局作用域上了！
  ```

- 性能问题

  > with 和 eval 会带来性能问题，JavaScript 在静态分析代码时会进行优化，这些优化是基于代码的位置来确定的，然而 with 和 eval 的存在会使得优化毫无意义。

## 函数作用域

函数外部不能访问函数内部的作用域

## 块作用域

- with

- try/catch

  > catch 中存在块级作用域

- let

  > es6 加入

- const
  > es6 加入

## 变量提升

- var 存在变量提升，而且 var 会跳过已经声明的变量
- 函数优先，函数会优先提升
- 函数表达式不存在变量提升

## 闭包

## 垃圾回收
